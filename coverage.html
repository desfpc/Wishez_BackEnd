
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>Wishez_BackEnd: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/desfpc/Wishez_BackEnd/main.go (0.0%)</option>
				
				<option value="file1">github.com/desfpc/Wishez_DB/db.go (0.0%)</option>
				
				<option value="file2">github.com/desfpc/Wishez_Helpers/helpers.go (60.0%)</option>
				
				<option value="file3">github.com/desfpc/Wishez_User/user.go (0.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package main

import (
        "encoding/json"
        helpers "github.com/desfpc/Wishez_Helpers"
        "github.com/desfpc/Wishez_Type"
        "github.com/desfpc/Wishez_User"
        "io/ioutil"
        "log"
        "net/http"
)

var errors types.Errors

//возвращение тела запроса в виде строки
func getBody(w http.ResponseWriter, r *http.Request) string  <span class="cov0" title="0">{
        body, err := ioutil.ReadAll(r.Body)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("Error reading body: %v", err)
                errors = append(errors, "Error reading Body")
                return ""
        }</span>

        //log.Printf("Body: "+string(body))
        <span class="cov0" title="0">return string(body)</span>
}

//получение массива из JSON запроса
func getArrBody(w http.ResponseWriter, r *http.Request) types.JsonRequest <span class="cov0" title="0">{
        var body = getBody(w, r)
        var arr types.JsonRequest
        err := json.Unmarshal([]byte(body), &amp;arr)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("Error reading JSON from body: %v", err)
                errors = append(errors, "Error reading JSON from body: "+body)
        }</span>
        //var _, _ = json.Marshal(arr)
        //log.Printf("JsonBody: "+string(resp))
        <span class="cov0" title="0">return arr</span>
}

//вывод JSON ответа
func answer(w http.ResponseWriter, status string, answer types.JsonAnswerBody, response types.JsonRequest, code int)<span class="cov0" title="0">{

        w.Header().Set("Content-Type", "application/json")
        w.WriteHeader(code)

        jsonAnswer := types.JsonAnswer{Status: status, Answer: answer, Response: response, Errors: errors}

        json.NewEncoder(w).Encode(jsonAnswer)
        errors = make(types.Errors,0)
}</span>

//главный хандлер - все проверки и роутинг идут тут
func apiHandler(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{

        resp := getArrBody(w, r)
        accessToken := r.Header.Get("accessToken")
        refreshToken := r.Header.Get("refreshToken")

        authorizeError := true
        expireError:= false
        var auser types.User

        if accessToken != "" </span><span class="cov0" title="0">{
                auser, authorizeError, expireError = user.GetAuthorization(accessToken, "access")
        }</span>

        //проверяем роуты, доступные без авторизации
        <span class="cov0" title="0">var doRoute = true
        if authorizeError || expireError </span><span class="cov0" title="0">{
                if !(resp.Entity == "user" &amp;&amp; (resp.Action == "register" || resp.Action == "authorize" || resp.Action == "refreshToken")) </span><span class="cov0" title="0">{
                        doRoute = false
                }</span>
        }

        <span class="cov0" title="0">var anw types.JsonAnswerBody
        var code = 200
        var status = "success"

        if !doRoute </span><span class="cov0" title="0">{
                //формируем ошибки авторизации
                errors, code = helpers.AuthErrorAnswer(authorizeError, expireError)
        }</span> else<span class="cov0" title="0"> {
                //бегем по роутам
                switch resp.Entity </span>{
                case "user":<span class="cov0" title="0">
                        anw, errors, code = user.Route(resp, auser, refreshToken)</span>
                default:<span class="cov0" title="0">
                        errors, code = helpers.NoRouteErrorAnswer()</span>
                }
        }

        //если есть ошибки - ставим error status
        <span class="cov0" title="0">if len(errors) &gt; 0 </span><span class="cov0" title="0">{
                status = "error"
                if code == 200 </span><span class="cov0" title="0">{
                        code = 500
                }</span>
        }
        <span class="cov0" title="0">answer(w, status, anw, resp, code)</span>
}

//главная точнка входа - слушает все и выкидывает в apiHandler
func main() <span class="cov0" title="0">{
        errors = make(types.Errors,0)
        http.HandleFunc("/", apiHandler)
        log.Printf("Wishez BackEnd server started")
        log.Fatal(http.ListenAndServe(":8090", nil))
}</pre>
		
		<pre class="file" id="file1" style="display: none">package db

import (
        "database/sql"
        "github.com/desfpc/Wishez_Helpers"
        _ "github.com/go-sql-driver/mysql"
        "time"
)

// Db соединение с БД
func Db() *sql.DB  <span class="cov0" title="0">{
        //db, err := sql.Open("mysql", "root:025sergLBBK1&amp;*@/wishez")
        db, err := sql.Open("mysql", "root:root@/wishez")
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
        // See "Important settings" section.
        <span class="cov0" title="0">db.SetConnMaxLifetime(time.Minute * 3)
        db.SetMaxOpenConns(10)
        db.SetMaxIdleConns(10)

        return db</span>
}

func CheckCount(rows *sql.Rows) (count int) <span class="cov0" title="0">{
        for rows.Next() </span><span class="cov0" title="0">{
                err:= rows.Scan(&amp;count)
                helpers.CheckErr(err)
        }</span>
        <span class="cov0" title="0">return count</span>
}

// Escape аналог real_escape_strings
func Escape(sql string) string <span class="cov0" title="0">{
        dest := make([]byte, 0, 2*len(sql))
        var escape byte
        for i := 0; i &lt; len(sql); i++ </span><span class="cov0" title="0">{
                c := sql[i]

                escape = 0

                switch c </span>{
                case 0:<span class="cov0" title="0"> /* Must be escaped for 'mysql' */
                        escape = '0'
                        break</span>
                case '\n':<span class="cov0" title="0"> /* Must be escaped for logs */
                        escape = 'n'
                        break</span>
                case '\r':<span class="cov0" title="0">
                        escape = 'r'
                        break</span>
                case '\\':<span class="cov0" title="0">
                        escape = '\\'
                        break</span>
                case '\'':<span class="cov0" title="0">
                        escape = '\''
                        break</span>
                case '"':<span class="cov0" title="0"> /* Better safe than sorry */
                        escape = '"'
                        break</span>
                case '\032':<span class="cov0" title="0"> //十进制26,八进制32,十六进制1a, /* This gives problems on Win32 */
                        escape = 'Z'</span>
                }

                <span class="cov0" title="0">if escape != 0 </span><span class="cov0" title="0">{
                        dest = append(dest, '\\', escape)
                }</span> else<span class="cov0" title="0"> {
                        dest = append(dest, c)
                }</span>
        }

        <span class="cov0" title="0">return string(dest)</span>
}</pre>
		
		<pre class="file" id="file2" style="display: none">package helpers

import (
        "database/sql"
        "github.com/desfpc/Wishez_Type"
        "strconv"
)

func CheckErr(err error) <span class="cov0" title="0">{
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
}

func MakeStringFromSQL(str sql.NullString) string <span class="cov0" title="0">{
        if !str.Valid </span><span class="cov0" title="0">{
                return ""
        }</span>
        <span class="cov0" title="0">return str.String</span>
}

func MakeStringFromIntSQL(str sql.NullInt64) string <span class="cov0" title="0">{
        if !str.Valid </span><span class="cov0" title="0">{
                return ""
        }</span>
        <span class="cov0" title="0">return strconv.FormatInt(str.Int64, 10)</span>
}

// AuthErrorAnswer ответ при ошибке авторизации или протухании токена
func AuthErrorAnswer(authorizedError bool, expiredError bool) (types.Errors, int) <span class="cov8" title="1">{
        code := 200
        Errors := make(types.Errors,0)
        if authorizedError </span><span class="cov8" title="1">{
                Errors = append(Errors, "Authorization Required")
                code = 401
        }</span>else<span class="cov8" title="1"> if expiredError </span><span class="cov8" title="1">{
                Errors = append(Errors, "Access Token is Expired")
                code = 401
        }</span>
        <span class="cov8" title="1">return Errors, code</span>
}

func NoRouteErrorAnswer() (types.Errors, int) <span class="cov8" title="1">{
        Errors := make(types.Errors,0)
        Errors = append(Errors, "Entity and/or action not found")
        return Errors, 404
}</pre>
		
		<pre class="file" id="file3" style="display: none">package user

import (
        "crypto/hmac"
        "crypto/sha256"
        "database/sql"
        b64 "encoding/base64"
        "encoding/json"
        "github.com/desfpc/Wishez_DB"
        "github.com/desfpc/Wishez_Helpers"
        "github.com/desfpc/Wishez_Type"
        "golang.org/x/crypto/bcrypt"
        "log"
        "net"
        "regexp"
        "strconv"
        "strings"
        "time"
)

var key = []byte("Абдб%дв_3453453ы!всв^амвам_DFGVBdf*vdf43*453")
var dbres *sql.DB
var emailRegex = regexp.MustCompile("^[a-zA-Z0-9.!#$%&amp;'*+\\/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$")

func initDb()<span class="cov0" title="0">{
        dbres = db.Db()
}</span>

// MakeToken функция генерирует токен
func MakeToken(kind string, user types.User) string <span class="cov0" title="0">{

        //заголовок токена
        header := "{\"alg\":\"HS256\",\"typ\":\"JWT\"}"

        //ID пользователя
        id := strconv.Itoa(user.Id)

        //время жизни
        var lifetime string
        switch kind </span>{
        case "access":<span class="cov0" title="0">
                lifetime = strconv.FormatInt(time.Now().Unix() + 1800, 10)</span>
        case "refresh":<span class="cov0" title="0">
                lifetime = strconv.FormatInt(time.Now().Unix() + 5184000, 10)</span>
        }

        //тело токена
        <span class="cov0" title="0">body := "{\"user_id\":\""+id+"\",\"exp\":\""+lifetime+"\",\"kind\":\""+kind+"\"}"

        //подпись
        mac := hmac.New(sha256.New, key)
        mac.Write([]byte(header+body))
        signature := string(mac.Sum(nil))

        var token = b64.StdEncoding.EncodeToString([]byte(header+body+signature))

        return token</span>
}

// deconcatToken преобразование токена в читабельный вид
func deconcatToken(token string) types.Token <span class="cov0" title="0">{

        //декодируем base64 токен
        normalToken, _ := b64.StdEncoding.DecodeString(token)
        tokenString := string(normalToken)

        //паттерн для токена
        re := regexp.MustCompile("({.+})({.+?})(.+)")

        //заполняем токен
        var deconcactedToken types.Token

        deconcactedToken.Head = re.ReplaceAllString(tokenString, "$1")
        deconcactedToken.Body = re.ReplaceAllString(tokenString, "$2")
        deconcactedToken.Signature = re.ReplaceAllString(tokenString, "$3")

        return deconcactedToken
}</span>

// checkToken проверка токена на валидность
func checkToken(token types.Token) bool <span class="cov0" title="0">{

        //подпись
        mac := hmac.New(sha256.New, key)
        mac.Write([]byte(token.Head + token.Body))
        signature := mac.Sum(nil)

        return hmac.Equal(signature, []byte(token.Signature))
}</span>

// CheckUserToken проверка токена-строки на валидность
func CheckUserToken(token string) bool <span class="cov0" title="0">{
        var dToken = deconcatToken(token)
        return checkToken(dToken)
}</span>

// GetAuthorization проверка авторизации, получение активного пользователя
func GetAuthorization(token string, kind string) (types.User, bool, bool) <span class="cov0" title="0">{ //user, authorizeError, expireError
        dToken := deconcatToken(token)
        bodyString := dToken.Body
        body := make(types.TokenBody)
        var auser types.User

        if bodyString == "" </span><span class="cov0" title="0">{
                return auser, true, true
        }</span>

        <span class="cov0" title="0">err := json.Unmarshal([]byte(bodyString), &amp;body)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("Error reading JSON from token body: %v", err)
                log.Printf(bodyString)
                return auser, true, false
        }</span>

        <span class="cov0" title="0">if !CheckUserToken(token) </span><span class="cov0" title="0">{
                return auser, true, false
        }</span>

        <span class="cov0" title="0">if body["kind"] != kind </span><span class="cov0" title="0">{
                return auser, true, false
        }</span>

        <span class="cov0" title="0">if body["exp"] == "" </span><span class="cov0" title="0">{
                return auser, false, true
        }</span>

        //var exp int64
        <span class="cov0" title="0">exp, err := strconv.ParseInt(body["exp"], 10, 64)
        helpers.CheckErr(err)

        //получение данных пользователя
        auser = GetUserFromBD(body["user_id"])

        //если токен протух
        if exp &lt; time.Now().Unix() </span><span class="cov0" title="0">{
                return auser, false, true
        }</span>

        <span class="cov0" title="0">return auser, false, false</span>
}

func IsEmailValid(e string) bool <span class="cov0" title="0">{
        if len(e) &lt; 3 &amp;&amp; len(e) &gt; 254 </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov0" title="0">if !emailRegex.MatchString(e) </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov0" title="0">parts := strings.Split(e, "@")
        mx, err := net.LookupMX(parts[1])
        if err != nil || len(mx) == 0 </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov0" title="0">return true</span>
}

// Route роутер User
func Route(resp types.JsonRequest, auser types.User, refreshToken string) (types.JsonAnswerBody, types.Errors, int) <span class="cov0" title="0">{
        var body types.JsonAnswerBody
        var err types.Errors
        var code = 200

        //проверяем метод
        switch resp.Action </span>{
        case "register":<span class="cov0" title="0">
                body, err = registerUser(resp)</span>
        case "authorize":<span class="cov0" title="0">
                body, err = authorizeUser(resp)</span>
        case "getById":<span class="cov0" title="0">
                body, err = getUserByID(resp)</span>
        case "refreshToken":<span class="cov0" title="0">
                body, err = doRefreshToken(auser, refreshToken)</span>
        default:<span class="cov0" title="0">
                err, code = helpers.NoRouteErrorAnswer()</span>
        }
        <span class="cov0" title="0">return body, err, code</span>
}

//проверка пароля
func comparePasswords(hashedPwd string, plainPwd string) bool <span class="cov0" title="0">{
        byteHash := []byte(hashedPwd)
        bytePlain := []byte(plainPwd)
        err := bcrypt.CompareHashAndPassword(byteHash, bytePlain)
        if err != nil </span><span class="cov0" title="0">{
                log.Println(err)
                return false
        }</span>
        <span class="cov0" title="0">return true</span>
}

//генерация хэша пароля
func hashAndSalt(pwd []byte) string <span class="cov0" title="0">{
        hash, err := bcrypt.GenerateFromPassword(pwd, 10)
        if err != nil </span><span class="cov0" title="0">{
                log.Println(err)
        }</span>
        <span class="cov0" title="0">return string(hash)</span>
}

//обновление токенов
func doRefreshToken(auser types.User, refreshToken string) (types.JsonAnswerBody, types.Errors) <span class="cov0" title="0">{
        var tuser types.User
        var body types.JsonAnswerBody
        errors := make(types.Errors,0)
        authorizeError := true
        expireError:= false
        tuser, authorizeError, expireError = GetAuthorization(refreshToken, "refresh")
        //tuser, _, _ = GetAuthorization(refreshToken)
        if !authorizeError &amp;&amp; !expireError &amp;&amp; tuser.Id == auser.Id </span><span class="cov0" title="0">{
                item := make(types.JsonAnswerItem)
                item["accessToken"] = MakeToken("access", auser)
                item["refreshToken"] = MakeToken("refresh", auser)
                body.Items = make([]types.JsonAnswerItem,0)
                body.Items = append(body.Items, item)
        }</span> else<span class="cov0" title="0"> {
                errors = append(errors, "Wrong refreshToken")
        }</span>
        <span class="cov0" title="0">return body, errors</span>
}

//авторизация пользователя
func authorizeUser(resp types.JsonRequest) (types.JsonAnswerBody, types.Errors) <span class="cov0" title="0">{
        var body types.JsonAnswerBody
        var params = resp.Params
        Errors := make(types.Errors,0)

        //проверка на наличае логина
        var login, existsLogin = params["login"]
        if !existsLogin </span><span class="cov0" title="0">{
                Errors = append(Errors, "No login")
                return body, Errors
        }</span>
        <span class="cov0" title="0">login = db.Escape(login)  //для запроса в БД

        //проверка на наличае пароля
        var pass, existsPass = params["pass"]
        if !existsPass </span><span class="cov0" title="0">{
                Errors = append(Errors, "No pass")
                return body, Errors
        }</span>

        //получаем запись в БД по логину
        <span class="cov0" title="0">initDb()
        query := "SELECT * FROM users WHERE email = '"+login+"'"
        //log.Printf("query: "+query)
        results, err := dbres.Query(query)
        helpers.CheckErr(err)

        var user types.User

        //перебираем результаты
        for results.Next() </span><span class="cov0" title="0">{
                //пробуем все запихнуть в user-а
                err = results.Scan(&amp;user.Id, &amp;user.Email, &amp;user.Pass, &amp;user.Fio, &amp;user.Sex, &amp;user.Telegram, &amp;user.Instagram, &amp;user.Twitter, &amp;user.Facebook,
                        &amp;user.Phone, &amp;user.Role, &amp;user.Avatar, &amp;user.Google, &amp;user.CreatedAt)
                helpers.CheckErr(err)
        }</span>

        <span class="cov0" title="0">if comparePasswords(user.Pass, pass) </span><span class="cov0" title="0">{
                item := make(types.JsonAnswerItem)
                item["accessToken"] = MakeToken("access", user)
                item["refreshToken"] = MakeToken("refresh", user)
                body.Items = make([]types.JsonAnswerItem,0)
                body.Items = append(body.Items, item)
        }</span> else<span class="cov0" title="0"> {
                Errors = append(Errors, "Wrong user login or password")
                return body, Errors
        }</span>

        <span class="cov0" title="0">return body, Errors</span>
}

//регистрация нового пользователя
func registerUser(resp types.JsonRequest) (types.JsonAnswerBody, types.Errors) <span class="cov0" title="0">{

        var body types.JsonAnswerBody
        var params = resp.Params
        Errors := make(types.Errors,0)

        //проверка на наличае логина
        var login, existsLogin = params["login"]
        if !existsLogin </span><span class="cov0" title="0">{
                Errors = append(Errors, "No login")
                return body, Errors
        }</span>

        <span class="cov0" title="0">login = db.Escape(login)  //для запроса в БД
        if !IsEmailValid(login) </span><span class="cov0" title="0">{ //валидация login как email
                Errors = append(Errors, "Not valid login email")
                return body, Errors
        }</span>

        //проверка на наличае пароля
        <span class="cov0" title="0">var pass, existsPass = params["pass"]
        if !existsPass </span><span class="cov0" title="0">{
                Errors = append(Errors, "No pass")
                return body, Errors
        }</span>

        //проверка пользователя в базе
        <span class="cov0" title="0">initDb()
        query := "SELECT count(id) count FROM users WHERE email = '"+login+"'"
        //log.Printf("query: "+query)
        results, err := dbres.Query(query)
        helpers.CheckErr(err)

        count := db.CheckCount(results)

        if count &gt; 0 </span><span class="cov0" title="0">{
                Errors = append(Errors, "Login email "+login+" is already in use")
                return body, Errors
        }</span>

        //регистрация пользователя
        <span class="cov0" title="0">passHash := hashAndSalt([]byte(pass)) //хэш пароля

        res, err := dbres.Exec("INSERT INTO users (id, email, pass, fio, role, date_add, sex) " +
                "VALUES (null, ?, ?, ?, ?, NOW(), ?)",
                login, passHash, "Unknown", "user", "other")
        helpers.CheckErr(err)

        lastId, err := res.LastInsertId()
        helpers.CheckErr(err)

        item := make(types.JsonAnswerItem)
        item["Login"] = login
        item["Id"] = strconv.FormatInt(lastId, 10)

        body.Items = make([]types.JsonAnswerItem,0)
        body.Items = append(body.Items, item)

        return body, Errors</span>
}

// GetUserFromBD получение пользователя по его ID
func GetUserFromBD(id string) types.User <span class="cov0" title="0">{
        initDb()
        var user types.User

        query := "SELECT * FROM users WHERE id = "+id
        results, err := dbres.Query(query)
        helpers.CheckErr(err)

        //перебираем результаты
        for results.Next() </span><span class="cov0" title="0">{
                //пробуем все запихнуть в user-а
                err = results.Scan(&amp;user.Id, &amp;user.Email, &amp;user.Pass, &amp;user.Fio, &amp;user.Sex, &amp;user.Telegram, &amp;user.Instagram, &amp;user.Twitter, &amp;user.Facebook,
                        &amp;user.Phone, &amp;user.Role, &amp;user.Avatar, &amp;user.Google, &amp;user.CreatedAt)
                helpers.CheckErr(err)
        }</span>

        <span class="cov0" title="0">return user</span>
}

// ToJson формирование JsonAnswerItem из User
func ToJson (user types.User) types.JsonAnswerItem <span class="cov0" title="0">{

        item := make(types.JsonAnswerItem)
        item["id"] = strconv.Itoa(user.Id)

        if item["id"] != "0" </span><span class="cov0" title="0">{
                item["Email"] = user.Email
                item["Fio"] = user.Fio
                item["Sex"] = user.Sex
                item["Telegram"] = helpers.MakeStringFromSQL(user.Telegram)
                item["Instagram"] = helpers.MakeStringFromSQL(user.Instagram)
                item["Twitter"] = helpers.MakeStringFromSQL(user.Twitter)
                item["Facebook"] = helpers.MakeStringFromSQL(user.Facebook)
                item["Phone"] = helpers.MakeStringFromSQL(user.Phone)
                item["Role"] = user.Role
                item["Avatar"] = helpers.MakeStringFromIntSQL(user.Avatar)
                item["Google"] = helpers.MakeStringFromSQL(user.Google)
        }</span>

        <span class="cov0" title="0">return item</span>
}

//получение записи пользователя по id
func getUserByID(resp types.JsonRequest) (types.JsonAnswerBody, types.Errors) <span class="cov0" title="0">{

        var body types.JsonAnswerBody
        var params = resp.Params
        Errors := make(types.Errors,0)

        //проверка на наличае id
        var id, existsId = params["id"]
        if !existsId </span><span class="cov0" title="0">{
                Errors = append(Errors, "No user Id")

                return body, Errors
        }</span>

        <span class="cov0" title="0">user := GetUserFromBD(id)
        item := ToJson(user)

        if item["id"] == "0" </span><span class="cov0" title="0">{
                Errors = append(Errors, "No user with Id: "+id)
                return body, Errors
        }</span>

        <span class="cov0" title="0">body.Items = make([]types.JsonAnswerItem,0)
        body.Items = append(body.Items, item)

        return body, Errors</span>
}</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
